# Lazy Strip with Retry: Детальное предложение

## 1. Проблема текущего подхода

### Текущая логика (Eager Strip)

```
Backend Switch → Strip thinking blocks → Send request
```

**Проблемы:**

1. **Race condition**: несколько параллельных запросов могут "увидеть" флаг до его сброса
2. **Over-stripping**: strip происходит даже если запрос не содержит thinking blocks
3. **State management**: нужно отслеживать состояние между запросами
4. **Auxiliary requests**: вспомогательные запросы (например, для токенов) тоже триггерят strip

## 2. Lazy Strip подход

### Основная идея

```
Send request as-is → Check response
    ↓
Error 400 with thinking message?
    ↓
Yes → Strip thinking blocks → Retry request
    ↓
Success
```

**Ключевой принцип**: Strip thinking blocks **только после подтверждения**, что они вызывают ошибку.

## 3. Алгоритм работы

### Блок-схема 1: Основной поток запроса

```
┌─────────────────────────────────────┐
│         Получен HTTP запрос         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Сохранить оригинальное тело        │
│  запроса (для возможного retry)     │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Применить обычные трансформации    │
│  (без strip thinking blocks)        │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Отправить запрос upstream          │
└──────────────┬──────────────────────┘
               │
               ▼
        ┌──────────────┐
        │   Response   │
        └──────┬───────┘
               │
     ┌─────────┴─────────┐
     │                   │
     ▼                   ▼
┌─────────┐       ┌──────────────┐
│  Успех  │       │   Ошибка     │
│  2xx    │       │   4xx/5xx    │
└────┬────┘       └──────┬───────┘
     │                   │
     │                   ▼
     │          ┌─────────────────┐
     │          │ Status == 400?  │
     │          └────────┬────────┘
     │                   │
     │          ┌────────┴────────┐
     │          │                 │
     │          ▼                 ▼
     │   ┌────────────┐    ┌─────────────┐
     │   │  Да        │    │   Нет       │
     │   │  Проверить │    │  Вернуть    │
     │   │  сообщение │    │  ошибку     │
     │   └─────┬──────┘    └──────┬──────┘
     │         │                  │
     │         ▼                  │
     │  ┌─────────────────┐       │
     │  │ Содержит ошибку │       │
     │  │ про thinking?   │       │
     │  └────────┬────────┘       │
     │           │                │
     │    ┌──────┴──────┐         │
     │    │             │         │
     │    ▼             ▼         │
     │ ┌──────┐    ┌────────┐     │
     │ │  Да  │    │  Нет   │     │
     │ └──┬───┘    └───┬────┘     │
     │    │            │          │
     │    │            ▼          │
     │    │    ┌───────────────┐  │
     │    │    │ Вернуть 400   │  │
     │    │    │ как есть      │  │
     │    │    └───────────────┘  │
     │    │                       │
     │    ▼                       │
     │ ┌──────────────────────┐   │
     │ │ Strip thinking blocks│   │
     │ │ из сохранённого тела │   │
     │ └──────────┬───────────┘   │
     │            │               │
     │            ▼               │
     │ ┌──────────────────────┐   │
     │ │ Retry запроса        │   │
     │ │ (1 попытка)          │   │
     │ └──────────┬───────────┘   │
     │            │               │
     └────────────┴───────────────┘
                  │
                  ▼
         ┌──────────────┐
         │   Вернуть    │
         │   результат  │
         │   клиенту    │
         └──────────────┘
```

### Блок-схема 2: Определение thinking-ошибки

```
┌─────────────────────────────────────┐
│     Получено сообщение об ошибке    │
│     от upstream (тело ответа)       │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Попытка распарсить JSON            │
└──────────────┬──────────────────────┘
               │
               ▼
        ┌──────────────┐
        │  JSON valid? │
        └──────┬───────┘
               │
      ┌────────┴────────┐
      │                 │
      ▼                 ▼
┌───────────┐    ┌──────────────┐
│    Да     │    │     Нет      │
│           │    │              │
│ Извлечь   │    │ Проверить    │
│ error.    │    │ raw text     │
│ message   │    │ на ключевые  │
│           │    │ слова        │
└─────┬─────┘    └──────┬───────┘
      │                 │
      └────────┬────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Проверка паттернов ошибок:         │
│                                     │
│  1. "thinking" в сообщении          │
│     И                             │
│  2. Один из:                        │
│     - "signature"                   │
│     - "invalid"                     │
│     - "verification"                │
│     - "mismatch"                    │
│     - "unrecognized"                │
└──────────────┬──────────────────────┘
               │
               ▼
        ┌──────────────┐
        │  Match?      │
        └──────┬───────┘
               │
      ┌────────┴────────┐
      │                 │
      ▼                 ▼
┌───────────┐    ┌──────────────┐
│    Да     │    │     Нет      │
│           │    │              │
│ Это       │    │ Это другая   │
│ thinking  │    │ ошибка 400   │
│ ошибка    │    │              │
└───────────┘    └──────────────┘
```

## 4. Детали реализации

### 4.1 Сохранение оригинального запроса

**Проблема**: Тело запроса — stream, который можно прочитать только один раз.

**Решение**: Buffering

```
Псевдокод:

async fn handle_request(req: Request<Body>) -> Result<Response, Error> {
    // 1. Читаем весь body в буфер
    let body_bytes = req.body().collect().await?.to_bytes();
    
    // 2. Сохраняем копию для возможного retry
    let original_body = body_bytes.clone();
    
    // 3. Первый запрос
    let response = send_request(body_bytes).await;
    
    // 4. Если нужен retry — используем original_body
    if needs_retry(&response) {
        let stripped = strip_thinking_blocks(original_body);
        return send_request(stripped).await;
    }
    
    response
}
```

### 4.2 Идентификация ошибки

**Примеры сообщений от Claude API:**

- "Invalid thinking block: signature verification failed"
- "Unrecognized thinking block format"
- "Thinking block signature mismatch"
- "Invalid request: thinking block from incompatible model"

**Алгоритм:**

1. Проверить `status == 400`
2. Извлечь `error.message` из JSON
3. Проверить наличие "thinking" + одного из ключевых слов
4. Если match → это thinking-ошибка

### 4.3 Процесс strip при retry

```
Оригинальное тело
       │
       ▼
┌──────────────────────┐
│ Парсинг JSON         │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Поиск messages       │
│ в теле запроса       │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Итерация по messages │
└──────────┬───────────┘
           │
           ▼
    ┌──────────────┐
    │ Content      │
    │ является     │
    │ массивом?    │
    └──────┬───────┘
           │
    ┌──────┴──────┐
    │             │
    ▼             ▼
┌───────┐   ┌───────────┐
│  Да   │   │   Нет     │
│       │   │ (string)  │
│ Фильтр│   │           │
│ blocks│   │ Пропускаем│
│       │   │           │
└───┬───┘   └─────┬─────┘
    │             │
    └──────┬──────┘
           │
           ▼
┌──────────────────────┐
│ Удаляем blocks с:    │
│ - type: "thinking"   │
│ - type: "redacted_   │
│   thinking"          │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Удаляем поле         │
│ context_management   │
│ если было            │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Сериализация обратно │
│ в JSON               │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Retry запрос         │
└──────────────────────┘
```

## 5. Edge Cases

### 5.1 Параллельные запросы

**Сценарий**: Два запроса одновременно получают 400.

**Решение**: Каждый запрос независимо делает retry. Нет shared state → нет race condition.

### 5.2 Streaming ответы

**Сценарий**: Запрос с `stream: true`, ошибка приходит сразу.

**Решение**: Ошибка 400 приходит до начала streaming. Можно сделать retry без проблем.

### 5.3 Другие 400 ошибки

**Сценарий**: Ошибка 400 не связана с thinking (например, invalid model).

**Решение**: Проверка по message content. Если не match → не retry, возвращаем ошибку клиенту.

### 5.4 Retry loop

**Сценарий**: После strip всё равно 400.

**Решение**:

- Ограничение: только 1 retry на запрос
- Если после strip снова ошибка → возвращаем клиенту

### 5.5 Производительность

**Сценарий**: Каждый запрос с чужими thinking blocks вызывает 2 round-trip.

**Оптимизация**:

- Strip ошибки редки (только после backend switch)
- Кэширование: если запрос успешен без strip → следующие запросы не будут retry
- Можно добавить флаг "после switch" для оптимизации первого запроса

## 6. Сравнение подходов

| Аспект | Eager Strip (текущий) | Lazy Strip (предлагаемый) |
|--------|----------------------|---------------------------|
| **Когда strip** | Перед запросом | После ошибки |
| **Race condition** | Есть | Нет |
| **Over-stripping** | Да | Нет |
| **Round trips** | 1 всегда | 1-2 (редко 2) |
| **Сложность** | Средняя (state mgmt) | Ниже (нет state) |
| **Надёжность** | Средняя | Выше |
| **Observability** | Сложнее отследить | Явный retry в логах |

## 7. Интеграция с архитектурой

### Изменения по слоям:

**Proxy Layer (upstream.rs)**:

- Добавить buffering тела запроса
- Добавить логику retry с strip
- Убрать текущую логику `should_strip_thinking`

**Backend Layer (state.rs)**:

- Убрать `last_request_backend` и связанные методы
- Упростить state management

**Thinking Layer**:

- Добавить функцию `strip_thinking_from_bytes()` (для retry)
- Сохранить текущий `StripTransformer` для других режимов

### Поток данных:

```
Client Request
      │
      ▼
┌─────────────────┐
│  Buffer body    │
│  (save copy)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Try forward    │
│  (no strip)     │
└────────┬────────┘
         │
         ▼
    ┌─────────┐
    │ Response│
    └────┬────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
 Success   Error 400
    │         │
    │    ┌────┴────┐
    │    │Thinking?│
    │    └────┬────┘
    │         │
    │    ┌────┴────┐
    │    │   Да    │
    │    │  Strip  │
    │    │  Retry  │
    │    └────┬────┘
    │         │
    └────┬────┘
         │
         ▼
┌─────────────────┐
│ Return response │
│ to client       │
└─────────────────┘
```

## 8. Рекомендации

### MVP (минимальная реализация):

1. Buffering тела запроса
2. Проверка 400 + message content
3. Strip + retry один раз

### Улучшения (после MVP):

1. Кэширование "чистых" запросов
2. Метрики: счётчик retry
3. Точная настройка паттернов ошибок по vendor

### Риски:

- Нужно протестировать с реальными ошибками Claude API
- Возможны false positives в определении ошибки
- Увеличение latency при retry (редко)

---

*Документ создан: 2026-02-04*
