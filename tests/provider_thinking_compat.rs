//! Integration tests for provider thinking block compatibility.
//!
//! These tests verify real API behavior when handling thinking blocks
//! across different providers. They require actual API keys to run.
//!
//! Run with: cargo test --test provider_thinking_compat -- --ignored
//!
//! Required environment variables:
//! - TEST_PROVIDER_API_KEY: API key for the test provider
//! - TEST_PROVIDER_BASE_URL: Base URL for the provider (Anthropic-compatible)
//! - TEST_PROVIDER_MODEL: Model name to use for testing

use serde_json::{json, Value};
use std::env;

/// Test configuration from environment variables
struct TestConfig {
    api_key: String,
    base_url: String,
    model: String,
}

impl TestConfig {
    fn from_env() -> Result<Self, String> {
        Ok(Self {
            api_key: env::var("TEST_PROVIDER_API_KEY")
                .map_err(|_| "TEST_PROVIDER_API_KEY not set")?,
            base_url: env::var("TEST_PROVIDER_BASE_URL")
                .map_err(|_| "TEST_PROVIDER_BASE_URL not set")?,
            model: env::var("TEST_PROVIDER_MODEL")
                .map_err(|_| "TEST_PROVIDER_MODEL not set")?,
        })
    }
}

/// Test helper to make requests to an Anthropic-compatible endpoint
async fn provider_request(config: &TestConfig, body: Value) -> Result<(u16, Value), String> {
    let client = reqwest::Client::new();
    let url = format!("{}/v1/messages", config.base_url.trim_end_matches('/'));

    let response = client
        .post(&url)
        .header("x-api-key", &config.api_key)
        .header("Authorization", format!("Bearer {}", config.api_key))
        .header("anthropic-version", "2023-06-01")
        .header("content-type", "application/json")
        .json(&body)
        .send()
        .await
        .map_err(|e| format!("Request failed: {}", e))?;

    let status = response.status().as_u16();
    let body: Value = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse response: {}", e))?;

    Ok((status, body))
}

/// Test: Send thinking block with fake signature
///
/// This tests what happens when we send a thinking block with a signature
/// that was NOT generated by the current provider.
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_provider_with_foreign_thinking_signature() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    let body = json!({
        "model": config.model,
        "max_tokens": 1024,
        "messages": [
            {
                "role": "user",
                "content": "What is 2+2?"
            },
            {
                "role": "assistant",
                "content": [
                    {
                        "type": "thinking",
                        "thinking": "Let me calculate this simple addition.",
                        "signature": "FAKE_SIGNATURE_FROM_OTHER_PROVIDER_abc123xyz"
                    },
                    {
                        "type": "text",
                        "text": "2+2 equals 4."
                    }
                ]
            },
            {
                "role": "user",
                "content": "Are you sure?"
            }
        ]
    });

    let result = provider_request(&config, body).await;

    match result {
        Ok((status, response)) => {
            println!("Status: {}", status);
            println!("Response: {}", serde_json::to_string_pretty(&response).unwrap());

            if status == 400 {
                println!("\n==> Provider REJECTS foreign signatures (400 error)");
                println!("    This means we MUST transform thinking blocks when switching providers");
            } else if status == 200 {
                println!("\n==> Provider ACCEPTS foreign signatures (200 OK)");
                println!("    This means provider ignores/strips the signature field");
            } else {
                println!("\n==> Unexpected status code: {}", status);
            }
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}

/// Test: Send thinking block WITHOUT signature
///
/// This tests what happens when we strip the signature before sending.
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_provider_with_thinking_no_signature() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    let body = json!({
        "model": config.model,
        "max_tokens": 1024,
        "messages": [
            {
                "role": "user",
                "content": "What is 2+2?"
            },
            {
                "role": "assistant",
                "content": [
                    {
                        "type": "thinking",
                        "thinking": "Let me calculate this simple addition."
                        // No signature field
                    },
                    {
                        "type": "text",
                        "text": "2+2 equals 4."
                    }
                ]
            },
            {
                "role": "user",
                "content": "Are you sure?"
            }
        ]
    });

    let result = provider_request(&config, body).await;

    match result {
        Ok((status, response)) => {
            println!("Status: {}", status);
            println!("Response: {}", serde_json::to_string_pretty(&response).unwrap());

            if status == 400 {
                println!("\n==> Provider REJECTS thinking without signature (400 error)");
                println!("    This means we MUST strip thinking blocks entirely");
            } else if status == 200 {
                println!("\n==> Provider ACCEPTS thinking without signature (200 OK)");
                println!("    Thinking blocks without signature are accepted");
            } else {
                println!("\n==> Unexpected status code: {}", status);
            }
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}

/// Test: Send thinking converted to text block
///
/// This tests replacing thinking blocks with plain text.
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_provider_with_thinking_as_text() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    let body = json!({
        "model": config.model,
        "max_tokens": 1024,
        "messages": [
            {
                "role": "user",
                "content": "What is 2+2?"
            },
            {
                "role": "assistant",
                "content": [
                    {
                        "type": "text",
                        "text": "Let me calculate this simple addition."
                    },
                    {
                        "type": "text",
                        "text": "2+2 equals 4."
                    }
                ]
            },
            {
                "role": "user",
                "content": "Are you sure?"
            }
        ]
    });

    let result = provider_request(&config, body).await;

    match result {
        Ok((status, response)) => {
            println!("Status: {}", status);
            println!("Response: {}", serde_json::to_string_pretty(&response).unwrap());

            if status == 200 {
                println!("\n==> Provider ACCEPTS thinking as plain text (200 OK)");
                println!("    Converting thinking to text is a viable approach");
            } else {
                println!("\n==> Unexpected status: {}", status);
            }
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}

/// Test: Check provider response format for thinking
///
/// This tests what format the provider returns when it generates thinking.
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_provider_thinking_response_format() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    let body = json!({
        "model": config.model,
        "max_tokens": 2048,
        "thinking": {
            "type": "enabled",
            "budget_tokens": 1000
        },
        "messages": [
            {
                "role": "user",
                "content": "Think step by step: what is 17 * 23?"
            }
        ]
    });

    let result = provider_request(&config, body).await;

    match result {
        Ok((status, response)) => {
            println!("Status: {}", status);
            println!("Response: {}", serde_json::to_string_pretty(&response).unwrap());

            if status == 200 {
                if let Some(content) = response.get("content").and_then(|c| c.as_array()) {
                    for (i, block) in content.iter().enumerate() {
                        let block_type = block.get("type").and_then(|t| t.as_str());
                        let has_signature = block.get("signature").is_some();
                        let has_thinking = block.get("thinking").is_some();

                        println!("\n==> Block {}: type={:?}, has_signature={}, has_thinking={}",
                                 i, block_type, has_signature, has_thinking);

                        if block_type == Some("thinking") && has_signature {
                            println!("    Provider returns Anthropic-style thinking blocks WITH signature");
                        } else if block_type == Some("thinking") && !has_signature {
                            println!("    Provider returns thinking blocks WITHOUT signature");
                        }
                    }
                }
            }
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}

/// Test: Full cycle - get response from provider, then send to provider with that history
///
/// This simulates: Provider response -> switch backend -> new request with history
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_full_cycle_same_provider() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    // Step 1: Get a response from provider with thinking enabled
    let first_request = json!({
        "model": config.model,
        "max_tokens": 2048,
        "thinking": {
            "type": "enabled",
            "budget_tokens": 1000
        },
        "messages": [
            {
                "role": "user",
                "content": "What is 5+3? Think step by step."
            }
        ]
    });

    let (status1, response1) = match provider_request(&config, first_request).await {
        Ok(r) => r,
        Err(e) => {
            println!("First request failed: {}", e);
            return;
        }
    };

    println!("=== Step 1: Initial provider response ===");
    println!("Status: {}", status1);
    println!("Response: {}", serde_json::to_string_pretty(&response1).unwrap());

    if status1 != 200 {
        println!("First request failed, cannot continue");
        return;
    }

    // Step 2: Build second request with history from first response
    let content_blocks = response1.get("content").and_then(|c| c.as_array());
    if content_blocks.is_none() {
        println!("No content in response");
        return;
    }

    let second_request = json!({
        "model": config.model,
        "max_tokens": 1024,
        "messages": [
            {
                "role": "user",
                "content": "What is 5+3? Think step by step."
            },
            {
                "role": "assistant",
                "content": content_blocks.unwrap()
            },
            {
                "role": "user",
                "content": "Now what is 10+20?"
            }
        ]
    });

    println!("\n=== Step 2: Second request with history ===");
    println!("Request: {}", serde_json::to_string_pretty(&second_request).unwrap());

    let (status2, response2) = match provider_request(&config, second_request).await {
        Ok(r) => r,
        Err(e) => {
            println!("Second request failed: {}", e);
            return;
        }
    };

    println!("\nStatus: {}", status2);
    println!("Response: {}", serde_json::to_string_pretty(&response2).unwrap());

    if status2 == 200 {
        println!("\n==> Full cycle WORKS");
    } else {
        println!("\n==> Full cycle FAILS with {}", status2);
        if let Some(error) = response2.get("error") {
            println!("Error details: {}", error);
        }
    }
}

/// Test: Simulated cross-provider switch
///
/// We simulate history from another provider and send to current provider
#[tokio::test]
#[ignore = "requires TEST_PROVIDER_* env vars"]
async fn test_cross_provider_switch_simulation() {
    let config = match TestConfig::from_env() {
        Ok(c) => c,
        Err(e) => {
            println!("Skipping: {}", e);
            return;
        }
    };

    // Simulate what a response from another provider looks like
    // (with a realistic-looking but fake signature)
    let simulated_history = json!({
        "model": config.model,
        "max_tokens": 1024,
        "messages": [
            {
                "role": "user",
                "content": "What is 5+3?"
            },
            {
                "role": "assistant",
                "content": [
                    {
                        "type": "thinking",
                        "thinking": "I need to add 5 and 3. 5 + 3 = 8.",
                        "signature": "WaUjzkypQ2mUEVM36O2TxuC06KN8xyfbJwyem2dw3URve/op91XWHOEBLLqIOMfFG/UvLEczmEsUjavLsomeMoreBase64DataHere=="
                    },
                    {
                        "type": "text",
                        "text": "5 + 3 = 8"
                    }
                ]
            },
            {
                "role": "user",
                "content": "Now what is 10+20?"
            }
        ]
    });

    println!("=== Test: Simulated cross-provider history ===");
    println!("Request: {}", serde_json::to_string_pretty(&simulated_history).unwrap());

    let (status, response) = match provider_request(&config, simulated_history).await {
        Ok(r) => r,
        Err(e) => {
            println!("Request failed: {}", e);
            return;
        }
    };

    println!("\nStatus: {}", status);
    println!("Response: {}", serde_json::to_string_pretty(&response).unwrap());

    if status == 200 {
        println!("\n==> Cross-provider history accepted");
    } else {
        println!("\n==> Provider REJECTS cross-provider history with {}", status);
        if let Some(error) = response.get("error") {
            println!("Error details: {}", error);
        }
    }
}
